/* tslint:disable */
/* eslint-disable */
/**
 * TabT Rest
 * This api is a bridge to the TabT SOAP API. It contacts TabT and cache results in order to reduce latency for some requests. More documentation will come.<br>       The data present in the api such as player names, club names, tournaments or match results are not managed by us. This information is made freely available by the Aile Francophone de Tennis de Table and the Vlaamse Tafeltennisliga. We therefore cannot be held responsible for the publication of this information. If changes need to be made, you should contact the responsible entity.     If you build an application on top of the BePing\'s api, be sure to do at least one of the following things:         <ul><li>If possible, set a X-Application-For header string. Include the name of your application, and a way to contact you in case something would go wrong.<br>       An example user agent string format is, which could result in the following string: beping/2.0.0 (floca.be; florent@floca.be). The use of a header like this isnâ€™t obligated or enforced, but allows for better communication.</li></ul>
 *
 * The version of the OpenAPI document: 1.9.0
 * Contact: f.cardoen@me.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Address
 */
export interface Address {
    /**
     *
     * @type {string}
     * @memberof Address
     */
    'Line1': string;
    /**
     *
     * @type {string}
     * @memberof Address
     */
    'Line2': string;
    /**
     *
     * @type {number}
     * @memberof Address
     */
    'ZipCode': number;
    /**
     *
     * @type {string}
     * @memberof Address
     */
    'Town': string;
}
/**
 *
 * @export
 * @interface ClubEntry
 */
export interface ClubEntry {
    /**
     *
     * @type {string}
     * @memberof ClubEntry
     */
    'UniqueIndex': string;
    /**
     *
     * @type {string}
     * @memberof ClubEntry
     */
    'Name': string;
    /**
     *
     * @type {string}
     * @memberof ClubEntry
     */
    'LongName': string;
    /**
     *
     * @type {number}
     * @memberof ClubEntry
     */
    'Category': number;
    /**
     *
     * @type {string}
     * @memberof ClubEntry
     */
    'CategoryName': string;
    /**
     *
     * @type {number}
     * @memberof ClubEntry
     */
    'VenueCount': number;
    /**
     *
     * @type {Array<VenueEntry>}
     * @memberof ClubEntry
     */
    'VenueEntries': Array<VenueEntry>;
}
/**
 *
 * @export
 * @interface DivisionEntry
 */
export interface DivisionEntry {
    /**
     *
     * @type {number}
     * @memberof DivisionEntry
     */
    'DivisionId': number;
    /**
     *
     * @type {string}
     * @memberof DivisionEntry
     */
    'DivisionName'?: string;
    /**
     *
     * @type {string}
     * @memberof DivisionEntry
     */
    'DivisionCategory': DivisionEntryDivisionCategoryTabt;
    /**
     *
     * @type {string}
     * @memberof DivisionEntry
     */
    'Level': DivisionEntryLevelTabt;
    /**
     *
     * @type {number}
     * @memberof DivisionEntry
     */
    'MatchType': number;
}

export const DivisionEntryDivisionCategoryTabt = {
    Men: 'MEN',
    Women: 'WOMEN',
    Veterans: 'VETERANS',
    VeteransWomen: 'VETERANS_WOMEN',
    Youth: 'YOUTH'
} as const;

export type DivisionEntryDivisionCategoryTabt = typeof DivisionEntryDivisionCategoryTabt[keyof typeof DivisionEntryDivisionCategoryTabt];
export const DivisionEntryLevelTabt = {
    National: 'NATIONAL',
    Hainaut: 'HAINAUT',
    VlaamsBrabantBr: 'VLAAMS_BRABANT_BR',
    SuperDivision: 'SUPER_DIVISION',
    OostVlanderen: 'OOST_VLANDEREN',
    Antwerp: 'ANTWERP',
    WestVlaanderen: 'WEST_VLAANDEREN',
    Limburg: 'LIMBURG',
    BrusselsBrabantWallon: 'BRUSSELS_BRABANT_WALLON',
    Namur: 'NAMUR',
    Liege: 'LIEGE',
    Luxembourg: 'LUXEMBOURG',
    RegionVttl: 'REGION_VTTL',
    Iwb: 'IWB'
} as const;

export type DivisionEntryLevelTabt = typeof DivisionEntryLevelTabt[keyof typeof DivisionEntryLevelTabt];

/**
 *
 * @export
 * @interface DoubleTeam
 */
export interface DoubleTeam {
    /**
     *
     * @type {number}
     * @memberof DoubleTeam
     */
    'Position': number;
    /**
     *
     * @type {string}
     * @memberof DoubleTeam
     */
    'Team': string;
    /**
     *
     * @type {boolean}
     * @memberof DoubleTeam
     */
    'IsForfeited': boolean;
}
/**
 *
 * @export
 * @interface Head2HeadData
 */
export interface Head2HeadData {
    /**
     *
     * @type {number}
     * @memberof Head2HeadData
     */
    'head2HeadCount': number;
    /**
     *
     * @type {number}
     * @memberof Head2HeadData
     */
    'victoryCount': number;
    /**
     *
     * @type {number}
     * @memberof Head2HeadData
     */
    'defeatCount': number;
    /**
     *
     * @type {string}
     * @memberof Head2HeadData
     */
    'lastVictory'?: string;
    /**
     *
     * @type {string}
     * @memberof Head2HeadData
     */
    'lastDefeat'?: string;
    /**
     *
     * @type {string}
     * @memberof Head2HeadData
     */
    'firstVictory'?: string;
    /**
     *
     * @type {Array<MatchEntryHistory>}
     * @memberof Head2HeadData
     */
    'matchEntryHistory': Array<MatchEntryHistory>;
    /**
     *
     * @type {PlayersInfo}
     * @memberof Head2HeadData
     */
    'playersInfo': PlayersInfo;
}
/**
 *
 * @export
 * @interface IndividualMatchResult
 */
export interface IndividualMatchResult {
    /**
     *
     * @type {number}
     * @memberof IndividualMatchResult
     */
    'Position': number;
    /**
     *
     * @type {Array<string>}
     * @memberof IndividualMatchResult
     */
    'HomePlayerMatchIndex': Array<number>;
    /**
     *
     * @type {Array<string>}
     * @memberof IndividualMatchResult
     */
    'HomePlayerUniqueIndex': Array<number>;
    /**
     *
     * @type {Array<string>}
     * @memberof IndividualMatchResult
     */
    'AwayPlayerMatchIndex': Array<number>;
    /**
     *
     * @type {Array<string>}
     * @memberof IndividualMatchResult
     */
    'AwayPlayerUniqueIndex': Array<number>;
    /**
     *
     * @type {number}
     * @memberof IndividualMatchResult
     */
    'HomeSetCount': number;
    /**
     *
     * @type {number}
     * @memberof IndividualMatchResult
     */
    'AwaySetCount': number;
    /**
     *
     * @type {boolean}
     * @memberof IndividualMatchResult
     */
    'IsHomeForfeited': boolean;
    /**
     *
     * @type {boolean}
     * @memberof IndividualMatchResult
     */
    'IsAwayForfeited': boolean;
    /**
     *
     * @type {string}
     * @memberof IndividualMatchResult
     */
    'Scores': string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    'status'?: string;
    /**
     *
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof InlineResponse200
     */
    'info'?: { [key: string]: { [key: string]: string; }; } | null;
    /**
     *
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof InlineResponse200
     */
    'error'?: { [key: string]: { [key: string]: string; }; } | null;
    /**
     *
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof InlineResponse200
     */
    'details'?: { [key: string]: { [key: string]: string; }; };
}
/**
 *
 * @export
 * @interface InlineResponse503
 */
export interface InlineResponse503 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse503
     */
    'status'?: string;
    /**
     *
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof InlineResponse503
     */
    'info'?: { [key: string]: { [key: string]: string; }; } | null;
    /**
     *
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof InlineResponse503
     */
    'error'?: { [key: string]: { [key: string]: string; }; } | null;
    /**
     *
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof InlineResponse503
     */
    'details'?: { [key: string]: { [key: string]: string; }; };
}
/**
 *
 * @export
 * @interface InternalIdentifiersDTO
 */
export interface InternalIdentifiersDTO {
    /**
     *
     * @type {number}
     * @memberof InternalIdentifiersDTO
     */
    'clubInternalIdentifier': number;
    /**
     *
     * @type {number}
     * @memberof InternalIdentifiersDTO
     */
    'playerInternalIdentifier': number;
}
/**
 *
 * @export
 * @interface MatchDetails
 */
export interface MatchDetails {
    /**
     *
     * @type {boolean}
     * @memberof MatchDetails
     */
    'DetailsCreated': boolean;
    /**
     *
     * @type {string}
     * @memberof MatchDetails
     */
    'StartTime': string;
    /**
     *
     * @type {string}
     * @memberof MatchDetails
     */
    'EndTime': string;
    /**
     *
     * @type {number}
     * @memberof MatchDetails
     */
    'HomeCaptain': number;
    /**
     *
     * @type {number}
     * @memberof MatchDetails
     */
    'AwayCaptain': number;
    /**
     *
     * @type {number}
     * @memberof MatchDetails
     */
    'Referee': number;
    /**
     *
     * @type {number}
     * @memberof MatchDetails
     */
    'HallCommissioner': number;
    /**
     *
     * @type {Players}
     * @memberof MatchDetails
     */
    'HomePlayers': Players;
    /**
     *
     * @type {Players}
     * @memberof MatchDetails
     */
    'AwayPlayers': Players;
    /**
     *
     * @type {Array<IndividualMatchResult>}
     * @memberof MatchDetails
     */
    'IndividualMatchResults': Array<IndividualMatchResult>;
    /**
     *
     * @type {number}
     * @memberof MatchDetails
     */
    'MatchSystem': number;
    /**
     *
     * @type {number}
     * @memberof MatchDetails
     */
    'HomeScore': number;
    /**
     *
     * @type {number}
     * @memberof MatchDetails
     */
    'AwayScore': number;
    /**
     *
     * @type {number}
     * @memberof MatchDetails
     */
    'CommentCount': number;
    /**
     *
     * @type {Array<string>}
     * @memberof MatchDetails
     */
    'CommentEntries': Array<string>;
}
/**
 *
 * @export
 * @interface MatchEntryHistory
 */
export interface MatchEntryHistory {
    /**
     *
     * @type {number}
     * @memberof MatchEntryHistory
     */
    'season'?: number;
    /**
     *
     * @type {string}
     * @memberof MatchEntryHistory
     */
    'date': string;
    /**
     *
     * @type {TeamMatchesEntry}
     * @memberof MatchEntryHistory
     */
    'matchEntry': TeamMatchesEntry;
    /**
     *
     * @type {string}
     * @memberof MatchEntryHistory
     */
    'playerRanking': string;
    /**
     *
     * @type {string}
     * @memberof MatchEntryHistory
     */
    'opponentRanking': string;
    /**
     *
     * @type {string}
     * @memberof MatchEntryHistory
     */
    'score': string;
}
/**
 *
 * @export
 * @interface MatchSystemEntry
 */
export interface MatchSystemEntry {
    /**
     *
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'UniqueIndex': number;
    /**
     *
     * @type {string}
     * @memberof MatchSystemEntry
     */
    'Name': string;
    /**
     *
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'SingleMatchCount': number;
    /**
     *
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'DoubleMatchCount': number;
    /**
     *
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'SetCount': number;
    /**
     *
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'PointCount': number;
    /**
     *
     * @type {boolean}
     * @memberof MatchSystemEntry
     */
    'ForcedDoubleTeams': boolean;
    /**
     *
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'SubstituteCount': number;
    /**
     *
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'TeamMatchCount': number;
    /**
     *
     * @type {Array<string>}
     * @memberof MatchSystemEntry
     */
    'TeamMatchDefinitionEntries': Array<string>;
}
/**
 *
 * @export
 * @interface MemberEntry
 */
export interface MemberEntry {
    /**
     *
     * @type {number}
     * @memberof MemberEntry
     */
    'Position': number;
    /**
     *
     * @type {number}
     * @memberof MemberEntry
     */
    'UniqueIndex': number;
    /**
     *
     * @type {number}
     * @memberof MemberEntry
     */
    'RankingIndex': number;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'FirstName': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'LastName': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'Ranking': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'Status': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'Club': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'Gender': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'Category': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'BirthDate'?: string;
    /**
     *
     * @type {boolean}
     * @memberof MemberEntry
     */
    'MedicalAttestation'?: boolean;
    /**
     *
     * @type {number}
     * @memberof MemberEntry
     */
    'RankingPointsCount'?: number;
    /**
     *
     * @type {Array<RankingPointsEntry>}
     * @memberof MemberEntry
     */
    'RankingPointsEntries'?: Array<RankingPointsEntry>;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'Email'?: string;
    /**
     *
     * @type {Phone}
     * @memberof MemberEntry
     */
    'Phone'?: Phone;
    /**
     *
     * @type {Address}
     * @memberof MemberEntry
     */
    'Address'?: Address;
    /**
     *
     * @type {number}
     * @memberof MemberEntry
     */
    'ResultCount'?: number;
    /**
     *
     * @type {Array<MemberEntryResultEntry>}
     * @memberof MemberEntry
     */
    'ResultEntries'?: Array<MemberEntryResultEntry>;
    /**
     *
     * @type {string}
     * @memberof MemberEntry
     */
    'NationalNumber'?: string;
}
/**
 *
 * @export
 * @interface MemberEntryResultEntry
 */
export interface MemberEntryResultEntry {
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'Date': string;
    /**
     *
     * @type {number}
     * @memberof MemberEntryResultEntry
     */
    'UniqueIndex': number;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'FirstName': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'LastName': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'Ranking': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'Result': string;
    /**
     *
     * @type {number}
     * @memberof MemberEntryResultEntry
     */
    'SetFor': number;
    /**
     *
     * @type {number}
     * @memberof MemberEntryResultEntry
     */
    'SetAgainst': number;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'CompetitionType': MemberEntryResultEntryCompetitionTypeTabt;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'Club': string;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'MatchId'?: string;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'MatchUniqueId'?: string;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'TournamentName'?: string;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'TournamentSerieName'?: string;
    /**
     *
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'TeamName'?: string;
    /**
     *
     * @type {number}
     * @memberof MemberEntryResultEntry
     */
    'RankingEvaluationCount'?: number;
    /**
     *
     * @type {Array<RankingEvaluationEntry>}
     * @memberof MemberEntryResultEntry
     */
    'RankingEvaluationEntries'?: Array<RankingEvaluationEntry>;
}

export const MemberEntryResultEntryCompetitionTypeTabt = {
    C: 'C',
    T: 'T'
} as const;

export type MemberEntryResultEntryCompetitionTypeTabt = typeof MemberEntryResultEntryCompetitionTypeTabt[keyof typeof MemberEntryResultEntryCompetitionTypeTabt];

/**
 *
 * @export
 * @interface MemberResults
 */
export interface MemberResults {
    /**
     *
     * @type {number}
     * @memberof MemberResults
     */
    'played': number;
    /**
     *
     * @type {number}
     * @memberof MemberResults
     */
    'win': number;
    /**
     *
     * @type {number}
     * @memberof MemberResults
     */
    'lose': number;
    /**
     *
     * @type {number}
     * @memberof MemberResults
     */
    'uniqueIndex': number;
    /**
     *
     * @type {string}
     * @memberof MemberResults
     */
    'firstName': string;
    /**
     *
     * @type {string}
     * @memberof MemberResults
     */
    'lastName': string;
    /**
     *
     * @type {string}
     * @memberof MemberResults
     */
    'ranking': string;
    /**
     *
     * @type {number}
     * @memberof MemberResults
     */
    'winPourcentage': number;
    /**
     *
     * @type {number}
     * @memberof MemberResults
     */
    'losePourcentage': number;
}
/**
 *
 * @export
 * @interface Phone
 */
export interface Phone {
    /**
     *
     * @type {string}
     * @memberof Phone
     */
    'Home': string;
    /**
     *
     * @type {string}
     * @memberof Phone
     */
    'Work': string;
    /**
     *
     * @type {string}
     * @memberof Phone
     */
    'Mobile': string;
    /**
     *
     * @type {string}
     * @memberof Phone
     */
    'Fax': string;
}
/**
 *
 * @export
 * @interface Player
 */
export interface Player {
    /**
     *
     * @type {number}
     * @memberof Player
     */
    'Position': number;
    /**
     *
     * @type {number}
     * @memberof Player
     */
    'UniqueIndex': number;
    /**
     *
     * @type {string}
     * @memberof Player
     */
    'FirstName': string;
    /**
     *
     * @type {string}
     * @memberof Player
     */
    'LastName': string;
    /**
     *
     * @type {string}
     * @memberof Player
     */
    'Ranking': string;
    /**
     *
     * @type {number}
     * @memberof Player
     */
    'VictoryCount': number;
    /**
     *
     * @type {boolean}
     * @memberof Player
     */
    'IsForfeited': boolean;
}
/**
 *
 * @export
 * @interface Players
 */
export interface Players {
    /**
     *
     * @type {number}
     * @memberof Players
     */
    'PlayerCount': number;
    /**
     *
     * @type {number}
     * @memberof Players
     */
    'DoubleTeamCount': number;
    /**
     *
     * @type {Array<Player>}
     * @memberof Players
     */
    'Players'?: Array<Player>;
    /**
     *
     * @type {Array<DoubleTeam>}
     * @memberof Players
     */
    'DoubleTeams'?: Array<DoubleTeam>;
}
/**
 *
 * @export
 * @interface PlayersInfo
 */
export interface PlayersInfo {
    /**
     *
     * @type {number}
     * @memberof PlayersInfo
     */
    'playerUniqueIndex': number;
    /**
     *
     * @type {number}
     * @memberof PlayersInfo
     */
    'opponentPlayerUniqueIndex': number;
    /**
     *
     * @type {string}
     * @memberof PlayersInfo
     */
    'playerName': string;
    /**
     *
     * @type {string}
     * @memberof PlayersInfo
     */
    'opponentPlayerName': string;
}
/**
 *
 * @export
 * @interface RankingEntry
 */
export interface RankingEntry {
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'Position': number;
    /**
     *
     * @type {string}
     * @memberof RankingEntry
     */
    'Team': string;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'GamesPlayed': number;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'GamesWon': number;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'GamesLost': number;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'GamesDraw': number;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'GamesWO': number;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'IndividualMatchesWon': number;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'IndividualMatchesLost': number;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'IndividualSetsWon': number;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'IndividualSetsLost': number;
    /**
     *
     * @type {number}
     * @memberof RankingEntry
     */
    'Points': number;
    /**
     *
     * @type {string}
     * @memberof RankingEntry
     */
    'TeamClub': string;
}
/**
 *
 * @export
 * @interface RankingEvaluationEntry
 */
export interface RankingEvaluationEntry {
    /**
     *
     * @type {string}
     * @memberof RankingEvaluationEntry
     */
    'EvaluationType': string;
    /**
     *
     * @type {string}
     * @memberof RankingEvaluationEntry
     */
    'EvaluationValue': string;
}
/**
 *
 * @export
 * @interface RankingPointsEntry
 */
export interface RankingPointsEntry {
    /**
     *
     * @type {string}
     * @memberof RankingPointsEntry
     */
    'MethodName': string;
    /**
     *
     * @type {string}
     * @memberof RankingPointsEntry
     */
    'Value': string;
    /**
     *
     * @type {string}
     * @memberof RankingPointsEntry
     */
    'LastModified': string;
}
/**
 *
 * @export
 * @interface RedirectLinkDTO
 */
export interface RedirectLinkDTO {
    /**
     *
     * @type {string}
     * @memberof RedirectLinkDTO
     */
    'url': string;
}
/**
 *
 * @export
 * @interface RegisterTournament
 */
export interface RegisterTournament {
    /**
     *
     * @type {Array<string>}
     * @memberof RegisterTournament
     */
    'playerUniqueIndex': Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RegisterTournament
     */
    'unregister': boolean;
    /**
     *
     * @type {boolean}
     * @memberof RegisterTournament
     */
    'notifyPlayer': boolean;
}
/**
 *
 * @export
 * @interface RegistrationEntry
 */
export interface RegistrationEntry {
    /**
     *
     * @type {number}
     * @memberof RegistrationEntry
     */
    'UniqueIndex': number;
    /**
     *
     * @type {string}
     * @memberof RegistrationEntry
     */
    'RegistrationDate': string;
    /**
     *
     * @type {MemberEntry}
     * @memberof RegistrationEntry
     */
    'Member': MemberEntry;
    /**
     *
     * @type {ClubEntry}
     * @memberof RegistrationEntry
     */
    'Club': ClubEntry;
}
/**
 *
 * @export
 * @interface SeasonEntry
 */
export interface SeasonEntry {
    /**
     *
     * @type {number}
     * @memberof SeasonEntry
     */
    'Season': number;
    /**
     *
     * @type {string}
     * @memberof SeasonEntry
     */
    'Name': string;
    /**
     *
     * @type {boolean}
     * @memberof SeasonEntry
     */
    'IsCurrent': boolean;
}
/**
 *
 * @export
 * @interface TabtException
 */
export interface TabtException {
    /**
     *
     * @type {number}
     * @memberof TabtException
     */
    'errorCode'?: number;
    /**
     *
     * @type {string}
     * @memberof TabtException
     */
    'message': string;
    /**
     *
     * @type {number}
     * @memberof TabtException
     */
    'statusCode': number;
}
/**
 *
 * @export
 * @interface TeamEntry
 */
export interface TeamEntry {
    /**
     *
     * @type {string}
     * @memberof TeamEntry
     */
    'TeamId': string;
    /**
     *
     * @type {string}
     * @memberof TeamEntry
     */
    'Team': string;
    /**
     *
     * @type {number}
     * @memberof TeamEntry
     */
    'DivisionId': number;
    /**
     *
     * @type {string}
     * @memberof TeamEntry
     */
    'DivisionName': string;
    /**
     *
     * @type {string}
     * @memberof TeamEntry
     */
    'DivisionCategory': TeamEntryDivisionCategoryTabt;
    /**
     *
     * @type {number}
     * @memberof TeamEntry
     */
    'MatchType': number;
}

export const TeamEntryDivisionCategoryTabt = {
    Men: 'MEN',
    Women: 'WOMEN',
    Veterans: 'VETERANS',
    VeteransWomen: 'VETERANS_WOMEN',
    Youth: 'YOUTH'
} as const;

export type TeamEntryDivisionCategoryTabt = typeof TeamEntryDivisionCategoryTabt[keyof typeof TeamEntryDivisionCategoryTabt];

/**
 *
 * @export
 * @interface TeamMatchesEntry
 */
export interface TeamMatchesEntry {
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'DivisionName'?: string;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'MatchId': string;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'WeekName': string;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'Date': string;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'Time': string;
    /**
     *
     * @type {number}
     * @memberof TeamMatchesEntry
     */
    'Venue': number;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'VenueClub': string;
    /**
     *
     * @type {VenueEntry}
     * @memberof TeamMatchesEntry
     */
    'VenueEntry': VenueEntry;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'HomeClub': string;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'HomeTeam': string;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'AwayClub': string;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'AwayTeam': string;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'Score': string;
    /**
     *
     * @type {number}
     * @memberof TeamMatchesEntry
     */
    'MatchUniqueId': number;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'NextWeekName'?: string;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'PreviousWeekName'?: string;
    /**
     *
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsHomeForfeited': boolean;
    /**
     *
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsAwayForfeited': boolean;
    /**
     *
     * @type {MatchDetails}
     * @memberof TeamMatchesEntry
     */
    'MatchDetails'?: MatchDetails;
    /**
     *
     * @type {number}
     * @memberof TeamMatchesEntry
     */
    'DivisionId': number;
    /**
     *
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'DivisionCategory': TeamMatchesEntryDivisionCategoryTabt;
    /**
     *
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsHomeWithdrawn': boolean;
    /**
     *
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsAwayWithdrawn': boolean;
    /**
     *
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsValidated': boolean;
    /**
     *
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsLocked': boolean;
}

export const TeamMatchesEntryDivisionCategoryTabt = {
    Men: 'MEN',
    Women: 'WOMEN',
    Veterans: 'VETERANS',
    VeteransWomen: 'VETERANS_WOMEN',
    Youth: 'YOUTH'
} as const;

export type TeamMatchesEntryDivisionCategoryTabt = typeof TeamMatchesEntryDivisionCategoryTabt[keyof typeof TeamMatchesEntryDivisionCategoryTabt];

/**
 *
 * @export
 * @interface TestOutput
 */
export interface TestOutput {
    /**
     *
     * @type {string}
     * @memberof TestOutput
     */
    'Timestamp': string;
    /**
     *
     * @type {string}
     * @memberof TestOutput
     */
    'ApiVersion': string;
    /**
     *
     * @type {boolean}
     * @memberof TestOutput
     */
    'IsValidAccount': boolean;
    /**
     *
     * @type {string}
     * @memberof TestOutput
     */
    'Language': TestOutputLanguageTabt;
    /**
     *
     * @type {string}
     * @memberof TestOutput
     */
    'Database': string;
    /**
     *
     * @type {string}
     * @memberof TestOutput
     */
    'RequestorIp': string;
    /**
     *
     * @type {number}
     * @memberof TestOutput
     */
    'ConsumedTicks': number;
    /**
     *
     * @type {number}
     * @memberof TestOutput
     */
    'CurrentQuota': number;
    /**
     *
     * @type {number}
     * @memberof TestOutput
     */
    'AllowedQuota': number;
    /**
     *
     * @type {string}
     * @memberof TestOutput
     */
    'PhpVersion': string;
    /**
     *
     * @type {string}
     * @memberof TestOutput
     */
    'DbVersion': string;
}

export const TestOutputLanguageTabt = {
    En: 'en',
    Fr: 'fr',
    Nl: 'nl'
} as const;

export type TestOutputLanguageTabt = typeof TestOutputLanguageTabt[keyof typeof TestOutputLanguageTabt];

/**
 *
 * @export
 * @interface TournamentEntry
 */
export interface TournamentEntry {
    /**
     *
     * @type {number}
     * @memberof TournamentEntry
     */
    'UniqueIndex': number;
    /**
     *
     * @type {string}
     * @memberof TournamentEntry
     */
    'Name': string;
    /**
     *
     * @type {string}
     * @memberof TournamentEntry
     */
    'Level': TournamentEntryLevelTabt;
    /**
     *
     * @type {string}
     * @memberof TournamentEntry
     */
    'ExternalIndex': string;
    /**
     *
     * @type {string}
     * @memberof TournamentEntry
     */
    'DateFrom': string;
    /**
     *
     * @type {string}
     * @memberof TournamentEntry
     */
    'DateTo': string;
    /**
     *
     * @type {string}
     * @memberof TournamentEntry
     */
    'RegistrationDate': string;
    /**
     *
     * @type {object}
     * @memberof TournamentEntry
     */
    'Venue'?: object;
    /**
     *
     * @type {number}
     * @memberof TournamentEntry
     */
    'SerieCount': number;
    /**
     *
     * @type {Array<TournamentSerieEntry>}
     * @memberof TournamentEntry
     */
    'SerieEntries': Array<TournamentSerieEntry>;
}

export const TournamentEntryLevelTabt = {
    National: 'NATIONAL',
    Hainaut: 'HAINAUT',
    VlaamsBrabantBr: 'VLAAMS_BRABANT_BR',
    SuperDivision: 'SUPER_DIVISION',
    OostVlanderen: 'OOST_VLANDEREN',
    Antwerp: 'ANTWERP',
    WestVlaanderen: 'WEST_VLAANDEREN',
    Limburg: 'LIMBURG',
    BrusselsBrabantWallon: 'BRUSSELS_BRABANT_WALLON',
    Namur: 'NAMUR',
    Liege: 'LIEGE',
    Luxembourg: 'LUXEMBOURG',
    RegionVttl: 'REGION_VTTL',
    Iwb: 'IWB'
} as const;

export type TournamentEntryLevelTabt = typeof TournamentEntryLevelTabt[keyof typeof TournamentEntryLevelTabt];

/**
 *
 * @export
 * @interface TournamentSerieEntry
 */
export interface TournamentSerieEntry {
    /**
     *
     * @type {number}
     * @memberof TournamentSerieEntry
     */
    'UniqueIndex': number;
    /**
     *
     * @type {string}
     * @memberof TournamentSerieEntry
     */
    'Name': string;
    /**
     *
     * @type {number}
     * @memberof TournamentSerieEntry
     */
    'ResultCount'?: number;
    /**
     *
     * @type {Array<TournamentSerieResultEntry>}
     * @memberof TournamentSerieEntry
     */
    'ResultEntries'?: Array<TournamentSerieResultEntry>;
    /**
     *
     * @type {number}
     * @memberof TournamentSerieEntry
     */
    'RegistrationCount'?: number;
    /**
     *
     * @type {Array<RegistrationEntry>}
     * @memberof TournamentSerieEntry
     */
    'RegistrationEntries'?: Array<RegistrationEntry>;
}
/**
 *
 * @export
 * @interface TournamentSerieResultEntry
 */
export interface TournamentSerieResultEntry {
    /**
     *
     * @type {number}
     * @memberof TournamentSerieResultEntry
     */
    'Position': number;
    /**
     *
     * @type {Array<string>}
     * @memberof TournamentSerieResultEntry
     */
    'HomePlayerMatchIndex': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof TournamentSerieResultEntry
     */
    'HomePlayerUniqueIndex': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof TournamentSerieResultEntry
     */
    'AwayPlayerMatchIndex': Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof TournamentSerieResultEntry
     */
    'AwayPlayerUniqueIndex': Array<string>;
    /**
     *
     * @type {number}
     * @memberof TournamentSerieResultEntry
     */
    'HomeSetCount': number;
    /**
     *
     * @type {number}
     * @memberof TournamentSerieResultEntry
     */
    'AwaySetCount': number;
    /**
     *
     * @type {boolean}
     * @memberof TournamentSerieResultEntry
     */
    'IsHomeForfeited': boolean;
    /**
     *
     * @type {boolean}
     * @memberof TournamentSerieResultEntry
     */
    'IsAwayForfeited': boolean;
    /**
     *
     * @type {string}
     * @memberof TournamentSerieResultEntry
     */
    'Scores': string;
    /**
     *
     * @type {Array<Player>}
     * @memberof TournamentSerieResultEntry
     */
    'HomePlayer': Array<Player>;
    /**
     *
     * @type {Array<Player>}
     * @memberof TournamentSerieResultEntry
     */
    'AwayPlayer': Array<Player>;
}
/**
 *
 * @export
 * @interface VenueEntry
 */
export interface VenueEntry {
    /**
     *
     * @type {number}
     * @memberof VenueEntry
     */
    'Id': number;
    /**
     *
     * @type {number}
     * @memberof VenueEntry
     */
    'ClubVenue': number;
    /**
     *
     * @type {string}
     * @memberof VenueEntry
     */
    'Name': string;
    /**
     *
     * @type {string}
     * @memberof VenueEntry
     */
    'Street': string;
    /**
     *
     * @type {string}
     * @memberof VenueEntry
     */
    'Town': string;
    /**
     *
     * @type {string}
     * @memberof VenueEntry
     */
    'Phone': string;
    /**
     *
     * @type {string}
     * @memberof VenueEntry
     */
    'Comment': string;
    /**
     *
     * @type {string}
     * @memberof VenueEntry
     */
    'Lat'?: string;
    /**
     *
     * @type {string}
     * @memberof VenueEntry
     */
    'Lon'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof VenueEntry
     */
    'BoundingBox'?: Array<string>;
}
/**
 *
 * @export
 * @interface WeeklyELO
 */
export interface WeeklyELO {
    /**
     *
     * @type {string}
     * @memberof WeeklyELO
     */
    'weekName': string;
    /**
     *
     * @type {number}
     * @memberof WeeklyELO
     */
    'elo': number;
}
/**
 *
 * @export
 * @interface WeeklyNumericRanking
 */
export interface WeeklyNumericRanking {
    /**
     *
     * @type {string}
     * @memberof WeeklyNumericRanking
     */
    'weekName': string;
    /**
     *
     * @type {number}
     * @memberof WeeklyNumericRanking
     */
    'elo': number;
    /**
     *
     * @type {number}
     * @memberof WeeklyNumericRanking
     */
    'bel': number;
}
/**
 *
 * @export
 * @interface WeeklyNumericRankingV2
 */
export interface WeeklyNumericRankingV2 {
    /**
     *
     * @type {string}
     * @memberof WeeklyNumericRankingV2
     */
    'weekName': string;
    /**
     *
     * @type {number}
     * @memberof WeeklyNumericRankingV2
     */
    'elo': number;
    /**
     *
     * @type {number}
     * @memberof WeeklyNumericRankingV2
     */
    'belPts': number;
    /**
     *
     * @type {number}
     * @memberof WeeklyNumericRankingV2
     */
    'belPos': number;
}

/**
 * ClubsApi - axios parameter creator
 * @export
 */
export const ClubsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'} [clubCategory]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClubs: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, clubCategory?: 'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/clubs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clubCategory !== undefined) {
                localVarQueryParameter['clubCategory'] = clubCategory;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubById: async (clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findClubById', 'clubIndex', clubIndex)
            const localVarPath = `/v1/clubs/{clubIndex}`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [playerCategory]
         * @param {number} [uniqueIndex]
         * @param {string} [nameSearch]
         * @param {boolean} [extendedInformation]
         * @param {boolean} [rankingPointsInformation]
         * @param {boolean} [withResults]
         * @param {boolean} [withOpponentRankingEvaluation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubMembers: async (clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findClubMembers', 'clubIndex', clubIndex)
            const localVarPath = `/v1/clubs/{clubIndex}/members`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (playerCategory !== undefined) {
                localVarQueryParameter['playerCategory'] = playerCategory;
            }

            if (uniqueIndex !== undefined) {
                localVarQueryParameter['uniqueIndex'] = uniqueIndex;
            }

            if (nameSearch !== undefined) {
                localVarQueryParameter['nameSearch'] = nameSearch;
            }

            if (extendedInformation !== undefined) {
                localVarQueryParameter['extendedInformation'] = extendedInformation;
            }

            if (rankingPointsInformation !== undefined) {
                localVarQueryParameter['rankingPointsInformation'] = rankingPointsInformation;
            }

            if (withResults !== undefined) {
                localVarQueryParameter['withResults'] = withResults;
            }

            if (withOpponentRankingEvaluation !== undefined) {
                localVarQueryParameter['withOpponentRankingEvaluation'] = withOpponentRankingEvaluation;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubTeams: async (clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findClubTeams', 'clubIndex', clubIndex)
            const localVarPath = `/v1/clubs/{clubIndex}/teams`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} teamId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubTeamsMemberRanking: async (clubIndex: string, teamId: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findClubTeamsMemberRanking', 'clubIndex', clubIndex)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('findClubTeamsMemberRanking', 'teamId', teamId)
            const localVarPath = `/v1/clubs/{clubIndex}/teams/{teamId}/ranking`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMembersRanking: async (clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findMembersRanking', 'clubIndex', clubIndex)
            const localVarPath = `/v1/clubs/{clubIndex}/members/ranking`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubsApi - functional programming interface
 * @export
 */
export const ClubsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClubsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'} [clubCategory]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllClubs(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, clubCategory?: 'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClubEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllClubs(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, clubCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClubById(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClubEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClubById(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [playerCategory]
         * @param {number} [uniqueIndex]
         * @param {string} [nameSearch]
         * @param {boolean} [extendedInformation]
         * @param {boolean} [rankingPointsInformation]
         * @param {boolean} [withResults]
         * @param {boolean} [withOpponentRankingEvaluation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClubMembers(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClubMembers(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, playerCategory, uniqueIndex, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClubTeams(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClubTeams(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} teamId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClubTeamsMemberRanking(clubIndex: string, teamId: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberResults>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClubTeamsMemberRanking(clubIndex, teamId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMembersRanking(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberResults>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMembersRanking(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClubsApi - factory interface
 * @export
 */
export const ClubsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClubsApiFp(configuration)
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'} [clubCategory]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClubs(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, clubCategory?: 'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT', options?: any): AxiosPromise<Array<ClubEntry>> {
            return localVarFp.findAllClubs(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, clubCategory, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubById(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<ClubEntry> {
            return localVarFp.findClubById(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [playerCategory]
         * @param {number} [uniqueIndex]
         * @param {string} [nameSearch]
         * @param {boolean} [extendedInformation]
         * @param {boolean} [rankingPointsInformation]
         * @param {boolean} [withResults]
         * @param {boolean} [withOpponentRankingEvaluation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubMembers(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, options?: any): AxiosPromise<Array<MemberEntry>> {
            return localVarFp.findClubMembers(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, playerCategory, uniqueIndex, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubTeams(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: any): AxiosPromise<Array<TeamEntry>> {
            return localVarFp.findClubTeams(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} teamId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubTeamsMemberRanking(clubIndex: string, teamId: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: any): AxiosPromise<Array<MemberResults>> {
            return localVarFp.findClubTeamsMemberRanking(clubIndex, teamId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} clubIndex
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMembersRanking(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: any): AxiosPromise<Array<MemberResults>> {
            return localVarFp.findMembersRanking(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllClubs operation in ClubsApi.
 * @export
 * @interface ClubsApiFindAllClubsRequest
 */
export interface ClubsApiFindAllClubsRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'}
     * @memberof ClubsApiFindAllClubs
     */
    readonly clubCategory?: 'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'
}

/**
 * Request parameters for findClubById operation in ClubsApi.
 * @export
 * @interface ClubsApiFindClubByIdRequest
 */
export interface ClubsApiFindClubByIdRequest {
    /**
     *
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly clubIndex: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findClubMembers operation in ClubsApi.
 * @export
 * @interface ClubsApiFindClubMembersRequest
 */
export interface ClubsApiFindClubMembersRequest {
    /**
     *
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly clubIndex: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'}
     * @memberof ClubsApiFindClubMembers
     */
    readonly playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'

    /**
     *
     * @type {number}
     * @memberof ClubsApiFindClubMembers
     */
    readonly uniqueIndex?: number

    /**
     *
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly nameSearch?: string

    /**
     *
     * @type {boolean}
     * @memberof ClubsApiFindClubMembers
     */
    readonly extendedInformation?: boolean

    /**
     *
     * @type {boolean}
     * @memberof ClubsApiFindClubMembers
     */
    readonly rankingPointsInformation?: boolean

    /**
     *
     * @type {boolean}
     * @memberof ClubsApiFindClubMembers
     */
    readonly withResults?: boolean

    /**
     *
     * @type {boolean}
     * @memberof ClubsApiFindClubMembers
     */
    readonly withOpponentRankingEvaluation?: boolean
}

/**
 * Request parameters for findClubTeams operation in ClubsApi.
 * @export
 * @interface ClubsApiFindClubTeamsRequest
 */
export interface ClubsApiFindClubTeamsRequest {
    /**
     *
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly clubIndex: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {number}
     * @memberof ClubsApiFindClubTeams
     */
    readonly season?: number
}

/**
 * Request parameters for findClubTeamsMemberRanking operation in ClubsApi.
 * @export
 * @interface ClubsApiFindClubTeamsMemberRankingRequest
 */
export interface ClubsApiFindClubTeamsMemberRankingRequest {
    /**
     *
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly clubIndex: string

    /**
     *
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly teamId: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {number}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly season?: number
}

/**
 * Request parameters for findMembersRanking operation in ClubsApi.
 * @export
 * @interface ClubsApiFindMembersRankingRequest
 */
export interface ClubsApiFindMembersRankingRequest {
    /**
     *
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly clubIndex: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {number}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly season?: number
}

/**
 * ClubsApi - object-oriented interface
 * @export
 * @class ClubsApi
 * @extends {BaseAPI}
 */
export class ClubsApi extends BaseAPI {
    /**
     *
     * @param {ClubsApiFindAllClubsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findAllClubs(requestParameters: ClubsApiFindAllClubsRequest = {}, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findAllClubs(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.clubCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ClubsApiFindClubByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findClubById(requestParameters: ClubsApiFindClubByIdRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findClubById(requestParameters.clubIndex, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ClubsApiFindClubMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findClubMembers(requestParameters: ClubsApiFindClubMembersRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findClubMembers(requestParameters.clubIndex, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.playerCategory, requestParameters.uniqueIndex, requestParameters.nameSearch, requestParameters.extendedInformation, requestParameters.rankingPointsInformation, requestParameters.withResults, requestParameters.withOpponentRankingEvaluation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ClubsApiFindClubTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findClubTeams(requestParameters: ClubsApiFindClubTeamsRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findClubTeams(requestParameters.clubIndex, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ClubsApiFindClubTeamsMemberRankingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findClubTeamsMemberRanking(requestParameters: ClubsApiFindClubTeamsMemberRankingRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findClubTeamsMemberRanking(requestParameters.clubIndex, requestParameters.teamId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ClubsApiFindMembersRankingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findMembersRanking(requestParameters: ClubsApiFindMembersRankingRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findMembersRanking(requestParameters.clubIndex, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.season, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DivisionsApi - axios parameter creator
 * @export
 */
export const DivisionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {'no' | 'yes' | 'short'} [showDivisionName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDivisions: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: 'no' | 'yes' | 'short', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/divisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (showDivisionName !== undefined) {
                localVarQueryParameter['showDivisionName'] = showDivisionName;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {'no' | 'yes' | 'short'} [showDivisionName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionById: async (divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: 'no' | 'yes' | 'short', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('findDivisionById', 'divisionId', divisionId)
            const localVarPath = `/v1/divisions/{divisionId}`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (showDivisionName !== undefined) {
                localVarQueryParameter['showDivisionName'] = showDivisionName;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [weekName]
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionMatches: async (divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, weekName?: number, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('findDivisionMatches', 'divisionId', divisionId)
            const localVarPath = `/v1/divisions/{divisionId}/matches`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (weekName !== undefined) {
                localVarQueryParameter['weekName'] = weekName;
            }

            if (yearDateFrom !== undefined) {
                localVarQueryParameter['yearDateFrom'] = yearDateFrom;
            }

            if (yearDateTo !== undefined) {
                localVarQueryParameter['yearDateTo'] = yearDateTo;
            }

            if (withDetails !== undefined) {
                localVarQueryParameter['withDetails'] = withDetails;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionMembers: async (divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('findDivisionMembers', 'divisionId', divisionId)
            const localVarPath = `/v1/divisions/{divisionId}/members/ranking`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [weekName]
         * @param {number} [rankingSystem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionRanking: async (divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, weekName?: number, rankingSystem?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('findDivisionRanking', 'divisionId', divisionId)
            const localVarPath = `/v1/divisions/{divisionId}/ranking`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (weekName !== undefined) {
                localVarQueryParameter['weekName'] = weekName;
            }

            if (rankingSystem !== undefined) {
                localVarQueryParameter['rankingSystem'] = rankingSystem;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DivisionsApi - functional programming interface
 * @export
 */
export const DivisionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DivisionsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {'no' | 'yes' | 'short'} [showDivisionName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDivisions(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: 'no' | 'yes' | 'short', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DivisionEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDivisions(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, level, showDivisionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {'no' | 'yes' | 'short'} [showDivisionName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDivisionById(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: 'no' | 'yes' | 'short', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DivisionEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDivisionById(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, level, showDivisionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [weekName]
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDivisionMatches(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, weekName?: number, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamMatchesEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDivisionMatches(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, weekName, yearDateFrom, yearDateTo, withDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDivisionMembers(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberResults>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDivisionMembers(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [weekName]
         * @param {number} [rankingSystem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDivisionRanking(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, weekName?: number, rankingSystem?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDivisionRanking(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, weekName, rankingSystem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DivisionsApi - factory interface
 * @export
 */
export const DivisionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DivisionsApiFp(configuration)
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {'no' | 'yes' | 'short'} [showDivisionName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDivisions(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: 'no' | 'yes' | 'short', options?: any): AxiosPromise<Array<DivisionEntry>> {
            return localVarFp.findAllDivisions(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, level, showDivisionName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {'no' | 'yes' | 'short'} [showDivisionName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionById(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: 'no' | 'yes' | 'short', options?: any): AxiosPromise<DivisionEntry> {
            return localVarFp.findDivisionById(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, level, showDivisionName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [weekName]
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionMatches(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, weekName?: number, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, options?: any): AxiosPromise<Array<TeamMatchesEntry>> {
            return localVarFp.findDivisionMatches(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, weekName, yearDateFrom, yearDateTo, withDetails, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionMembers(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: any): AxiosPromise<Array<MemberResults>> {
            return localVarFp.findDivisionMembers(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} divisionId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [weekName]
         * @param {number} [rankingSystem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionRanking(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, weekName?: number, rankingSystem?: number, options?: any): AxiosPromise<Array<RankingEntry>> {
            return localVarFp.findDivisionRanking(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, weekName, rankingSystem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllDivisions operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindAllDivisionsRequest
 */
export interface DivisionsApiFindAllDivisionsRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindAllDivisions
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindAllDivisions
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindAllDivisions
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindAllDivisions
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindAllDivisions
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'}
     * @memberof DivisionsApiFindAllDivisions
     */
    readonly level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'

    /**
     *
     * @type {'no' | 'yes' | 'short'}
     * @memberof DivisionsApiFindAllDivisions
     */
    readonly showDivisionName?: 'no' | 'yes' | 'short'
}

/**
 * Request parameters for findDivisionById operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindDivisionByIdRequest
 */
export interface DivisionsApiFindDivisionByIdRequest {
    /**
     *
     * @type {number}
     * @memberof DivisionsApiFindDivisionById
     */
    readonly divisionId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindDivisionById
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindDivisionById
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindDivisionById
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindDivisionById
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindDivisionById
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'}
     * @memberof DivisionsApiFindDivisionById
     */
    readonly level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'

    /**
     *
     * @type {'no' | 'yes' | 'short'}
     * @memberof DivisionsApiFindDivisionById
     */
    readonly showDivisionName?: 'no' | 'yes' | 'short'
}

/**
 * Request parameters for findDivisionMatches operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindDivisionMatchesRequest
 */
export interface DivisionsApiFindDivisionMatchesRequest {
    /**
     *
     * @type {number}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly divisionId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {number}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly weekName?: number

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly yearDateFrom?: string

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly yearDateTo?: string

    /**
     *
     * @type {boolean}
     * @memberof DivisionsApiFindDivisionMatches
     */
    readonly withDetails?: boolean
}

/**
 * Request parameters for findDivisionMembers operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindDivisionMembersRequest
 */
export interface DivisionsApiFindDivisionMembersRequest {
    /**
     *
     * @type {number}
     * @memberof DivisionsApiFindDivisionMembers
     */
    readonly divisionId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindDivisionMembers
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindDivisionMembers
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindDivisionMembers
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindDivisionMembers
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindDivisionMembers
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {number}
     * @memberof DivisionsApiFindDivisionMembers
     */
    readonly season?: number
}

/**
 * Request parameters for findDivisionRanking operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindDivisionRankingRequest
 */
export interface DivisionsApiFindDivisionRankingRequest {
    /**
     *
     * @type {number}
     * @memberof DivisionsApiFindDivisionRanking
     */
    readonly divisionId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindDivisionRanking
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindDivisionRanking
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindDivisionRanking
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindDivisionRanking
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindDivisionRanking
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {number}
     * @memberof DivisionsApiFindDivisionRanking
     */
    readonly weekName?: number

    /**
     *
     * @type {number}
     * @memberof DivisionsApiFindDivisionRanking
     */
    readonly rankingSystem?: number
}

/**
 * DivisionsApi - object-oriented interface
 * @export
 * @class DivisionsApi
 * @extends {BaseAPI}
 */
export class DivisionsApi extends BaseAPI {
    /**
     *
     * @param {DivisionsApiFindAllDivisionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findAllDivisions(requestParameters: DivisionsApiFindAllDivisionsRequest = {}, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findAllDivisions(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.level, requestParameters.showDivisionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {DivisionsApiFindDivisionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findDivisionById(requestParameters: DivisionsApiFindDivisionByIdRequest, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findDivisionById(requestParameters.divisionId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.level, requestParameters.showDivisionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {DivisionsApiFindDivisionMatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findDivisionMatches(requestParameters: DivisionsApiFindDivisionMatchesRequest, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findDivisionMatches(requestParameters.divisionId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.weekName, requestParameters.yearDateFrom, requestParameters.yearDateTo, requestParameters.withDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {DivisionsApiFindDivisionMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findDivisionMembers(requestParameters: DivisionsApiFindDivisionMembersRequest, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findDivisionMembers(requestParameters.divisionId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {DivisionsApiFindDivisionRankingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findDivisionRanking(requestParameters: DivisionsApiFindDivisionRankingRequest, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findDivisionRanking(requestParameters.divisionId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.weekName, requestParameters.rankingSystem, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Head2HeadApi - axios parameter creator
 * @export
 */
export const Head2HeadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} playerUniqueIndex
         * @param {number} opponentUniqueIndex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHead2HeadMatches: async (playerUniqueIndex: number, opponentUniqueIndex: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerUniqueIndex' is not null or undefined
            assertParamExists('findHead2HeadMatches', 'playerUniqueIndex', playerUniqueIndex)
            // verify required parameter 'opponentUniqueIndex' is not null or undefined
            assertParamExists('findHead2HeadMatches', 'opponentUniqueIndex', opponentUniqueIndex)
            const localVarPath = `/v1/head2head/{playerUniqueIndex}/{opponentUniqueIndex}`
                .replace(`{${"playerUniqueIndex"}}`, encodeURIComponent(String(playerUniqueIndex)))
                .replace(`{${"opponentUniqueIndex"}}`, encodeURIComponent(String(opponentUniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Head2HeadApi - functional programming interface
 * @export
 */
export const Head2HeadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Head2HeadApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} playerUniqueIndex
         * @param {number} opponentUniqueIndex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findHead2HeadMatches(playerUniqueIndex: number, opponentUniqueIndex: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Head2HeadData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findHead2HeadMatches(playerUniqueIndex, opponentUniqueIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Head2HeadApi - factory interface
 * @export
 */
export const Head2HeadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Head2HeadApiFp(configuration)
    return {
        /**
         *
         * @param {number} playerUniqueIndex
         * @param {number} opponentUniqueIndex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHead2HeadMatches(playerUniqueIndex: number, opponentUniqueIndex: number, options?: any): AxiosPromise<Head2HeadData> {
            return localVarFp.findHead2HeadMatches(playerUniqueIndex, opponentUniqueIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findHead2HeadMatches operation in Head2HeadApi.
 * @export
 * @interface Head2HeadApiFindHead2HeadMatchesRequest
 */
export interface Head2HeadApiFindHead2HeadMatchesRequest {
    /**
     *
     * @type {number}
     * @memberof Head2HeadApiFindHead2HeadMatches
     */
    readonly playerUniqueIndex: number

    /**
     *
     * @type {number}
     * @memberof Head2HeadApiFindHead2HeadMatches
     */
    readonly opponentUniqueIndex: number
}

/**
 * Head2HeadApi - object-oriented interface
 * @export
 * @class Head2HeadApi
 * @extends {BaseAPI}
 */
export class Head2HeadApi extends BaseAPI {
    /**
     *
     * @param {Head2HeadApiFindHead2HeadMatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Head2HeadApi
     */
    public findHead2HeadMatches(requestParameters: Head2HeadApiFindHead2HeadMatchesRequest, options?: AxiosRequestConfig) {
        return Head2HeadApiFp(this.configuration).findHead2HeadMatches(requestParameters.playerUniqueIndex, requestParameters.opponentUniqueIndex, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        context: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRequest: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkHealth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async context(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.context(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testRequest(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testRequest(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHealth(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.checkHealth(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        context(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<void> {
            return localVarFp.context(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRequest(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<TestOutput> {
            return localVarFp.testRequest(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for context operation in HealthApi.
 * @export
 * @interface HealthApiContextRequest
 */
export interface HealthApiContextRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof HealthApiContext
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof HealthApiContext
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof HealthApiContext
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof HealthApiContext
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof HealthApiContext
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for testRequest operation in HealthApi.
 * @export
 * @interface HealthApiTestRequestRequest
 */
export interface HealthApiTestRequestRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtSeason?: string
}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public checkHealth(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {HealthApiContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public context(requestParameters: HealthApiContextRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).context(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {HealthApiTestRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public testRequest(requestParameters: HealthApiTestRequestRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).testRequest(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InternalIdentifiersApi - axios parameter creator
 * @export
 */
export const InternalIdentifiersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} clubUniqueIndex
         * @param {string} database
         * @param {number} playerUniqueIndex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalIds: async (clubUniqueIndex: string, database: string, playerUniqueIndex: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubUniqueIndex' is not null or undefined
            assertParamExists('getInternalIds', 'clubUniqueIndex', clubUniqueIndex)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getInternalIds', 'database', database)
            // verify required parameter 'playerUniqueIndex' is not null or undefined
            assertParamExists('getInternalIds', 'playerUniqueIndex', playerUniqueIndex)
            const localVarPath = `/v1/internal-identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clubUniqueIndex !== undefined) {
                localVarQueryParameter['clubUniqueIndex'] = clubUniqueIndex;
            }

            if (database !== undefined) {
                localVarQueryParameter['database'] = database;
            }

            if (playerUniqueIndex !== undefined) {
                localVarQueryParameter['playerUniqueIndex'] = playerUniqueIndex;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} clubUniqueIndex
         * @param {string} database
         * @param {number} playerUniqueIndex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisterLink: async (clubUniqueIndex: string, database: string, playerUniqueIndex: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubUniqueIndex' is not null or undefined
            assertParamExists('getRegisterLink', 'clubUniqueIndex', clubUniqueIndex)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getRegisterLink', 'database', database)
            // verify required parameter 'playerUniqueIndex' is not null or undefined
            assertParamExists('getRegisterLink', 'playerUniqueIndex', playerUniqueIndex)
            const localVarPath = `/v1/internal-identifiers/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clubUniqueIndex !== undefined) {
                localVarQueryParameter['clubUniqueIndex'] = clubUniqueIndex;
            }

            if (database !== undefined) {
                localVarQueryParameter['database'] = database;
            }

            if (playerUniqueIndex !== undefined) {
                localVarQueryParameter['playerUniqueIndex'] = playerUniqueIndex;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalIdentifiersApi - functional programming interface
 * @export
 */
export const InternalIdentifiersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalIdentifiersApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} clubUniqueIndex
         * @param {string} database
         * @param {number} playerUniqueIndex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInternalIds(clubUniqueIndex: string, database: string, playerUniqueIndex: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalIdentifiersDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInternalIds(clubUniqueIndex, database, playerUniqueIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} clubUniqueIndex
         * @param {string} database
         * @param {number} playerUniqueIndex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegisterLink(clubUniqueIndex: string, database: string, playerUniqueIndex: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectLinkDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegisterLink(clubUniqueIndex, database, playerUniqueIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InternalIdentifiersApi - factory interface
 * @export
 */
export const InternalIdentifiersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalIdentifiersApiFp(configuration)
    return {
        /**
         *
         * @param {string} clubUniqueIndex
         * @param {string} database
         * @param {number} playerUniqueIndex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalIds(clubUniqueIndex: string, database: string, playerUniqueIndex: number, options?: any): AxiosPromise<InternalIdentifiersDTO> {
            return localVarFp.getInternalIds(clubUniqueIndex, database, playerUniqueIndex, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} clubUniqueIndex
         * @param {string} database
         * @param {number} playerUniqueIndex
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisterLink(clubUniqueIndex: string, database: string, playerUniqueIndex: number, options?: any): AxiosPromise<RedirectLinkDTO> {
            return localVarFp.getRegisterLink(clubUniqueIndex, database, playerUniqueIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getInternalIds operation in InternalIdentifiersApi.
 * @export
 * @interface InternalIdentifiersApiGetInternalIdsRequest
 */
export interface InternalIdentifiersApiGetInternalIdsRequest {
    /**
     *
     * @type {string}
     * @memberof InternalIdentifiersApiGetInternalIds
     */
    readonly clubUniqueIndex: string

    /**
     *
     * @type {string}
     * @memberof InternalIdentifiersApiGetInternalIds
     */
    readonly database: string

    /**
     *
     * @type {number}
     * @memberof InternalIdentifiersApiGetInternalIds
     */
    readonly playerUniqueIndex: number
}

/**
 * Request parameters for getRegisterLink operation in InternalIdentifiersApi.
 * @export
 * @interface InternalIdentifiersApiGetRegisterLinkRequest
 */
export interface InternalIdentifiersApiGetRegisterLinkRequest {
    /**
     *
     * @type {string}
     * @memberof InternalIdentifiersApiGetRegisterLink
     */
    readonly clubUniqueIndex: string

    /**
     *
     * @type {string}
     * @memberof InternalIdentifiersApiGetRegisterLink
     */
    readonly database: string

    /**
     *
     * @type {number}
     * @memberof InternalIdentifiersApiGetRegisterLink
     */
    readonly playerUniqueIndex: number
}

/**
 * InternalIdentifiersApi - object-oriented interface
 * @export
 * @class InternalIdentifiersApi
 * @extends {BaseAPI}
 */
export class InternalIdentifiersApi extends BaseAPI {
    /**
     *
     * @param {InternalIdentifiersApiGetInternalIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalIdentifiersApi
     */
    public getInternalIds(requestParameters: InternalIdentifiersApiGetInternalIdsRequest, options?: AxiosRequestConfig) {
        return InternalIdentifiersApiFp(this.configuration).getInternalIds(requestParameters.clubUniqueIndex, requestParameters.database, requestParameters.playerUniqueIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {InternalIdentifiersApiGetRegisterLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalIdentifiersApi
     */
    public getRegisterLink(requestParameters: InternalIdentifiersApiGetRegisterLinkRequest, options?: AxiosRequestConfig) {
        return InternalIdentifiersApiFp(this.configuration).getRegisterLink(requestParameters.clubUniqueIndex, requestParameters.database, requestParameters.playerUniqueIndex, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MatchesApi - axios parameter creator
 * @export
 */
export const MatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchSystems: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId]
         * @param {string} [club]
         * @param {string} [team]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [divisionCategory]
         * @param {number} [weekName]
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {string} [showDivisionName]
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails]
         * @param {string} [matchId]
         * @param {string} [matchUniqueId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatches: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', weekName?: number, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, matchUniqueId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (divisionId !== undefined) {
                localVarQueryParameter['divisionId'] = divisionId;
            }

            if (club !== undefined) {
                localVarQueryParameter['club'] = club;
            }

            if (team !== undefined) {
                localVarQueryParameter['team'] = team;
            }

            if (divisionCategory !== undefined) {
                localVarQueryParameter['divisionCategory'] = divisionCategory;
            }

            if (weekName !== undefined) {
                localVarQueryParameter['weekName'] = weekName;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (showDivisionName !== undefined) {
                localVarQueryParameter['showDivisionName'] = showDivisionName;
            }

            if (yearDateFrom !== undefined) {
                localVarQueryParameter['yearDateFrom'] = yearDateFrom;
            }

            if (yearDateTo !== undefined) {
                localVarQueryParameter['yearDateTo'] = yearDateTo;
            }

            if (withDetails !== undefined) {
                localVarQueryParameter['withDetails'] = withDetails;
            }

            if (matchId !== undefined) {
                localVarQueryParameter['matchId'] = matchId;
            }

            if (matchUniqueId !== undefined) {
                localVarQueryParameter['matchUniqueId'] = matchUniqueId;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} matchUniqueId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId]
         * @param {string} [club]
         * @param {string} [team]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [divisionCategory]
         * @param {number} [weekName]
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {string} [showDivisionName]
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails]
         * @param {string} [matchId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchById: async (matchUniqueId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', weekName?: number, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchUniqueId' is not null or undefined
            assertParamExists('findMatchById', 'matchUniqueId', matchUniqueId)
            const localVarPath = `/v1/matches/{matchUniqueId}`
                .replace(`{${"matchUniqueId"}}`, encodeURIComponent(String(matchUniqueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (divisionId !== undefined) {
                localVarQueryParameter['divisionId'] = divisionId;
            }

            if (club !== undefined) {
                localVarQueryParameter['club'] = club;
            }

            if (team !== undefined) {
                localVarQueryParameter['team'] = team;
            }

            if (divisionCategory !== undefined) {
                localVarQueryParameter['divisionCategory'] = divisionCategory;
            }

            if (weekName !== undefined) {
                localVarQueryParameter['weekName'] = weekName;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (showDivisionName !== undefined) {
                localVarQueryParameter['showDivisionName'] = showDivisionName;
            }

            if (yearDateFrom !== undefined) {
                localVarQueryParameter['yearDateFrom'] = yearDateFrom;
            }

            if (yearDateTo !== undefined) {
                localVarQueryParameter['yearDateTo'] = yearDateTo;
            }

            if (withDetails !== undefined) {
                localVarQueryParameter['withDetails'] = withDetails;
            }

            if (matchId !== undefined) {
                localVarQueryParameter['matchId'] = matchId;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} matchSystemId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchSystemById: async (matchSystemId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchSystemId' is not null or undefined
            assertParamExists('findMatchSystemById', 'matchSystemId', matchSystemId)
            const localVarPath = `/v1/matches/systems/{matchSystemId}`
                .replace(`{${"matchSystemId"}}`, encodeURIComponent(String(matchSystemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchesApi - functional programming interface
 * @export
 */
export const MatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchesApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMatchSystems(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchSystemEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMatchSystems(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId]
         * @param {string} [club]
         * @param {string} [team]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [divisionCategory]
         * @param {number} [weekName]
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {string} [showDivisionName]
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails]
         * @param {string} [matchId]
         * @param {string} [matchUniqueId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMatches(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', weekName?: number, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, matchUniqueId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamMatchesEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMatches(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, divisionId, club, team, divisionCategory, weekName, level, showDivisionName, yearDateFrom, yearDateTo, withDetails, matchId, matchUniqueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} matchUniqueId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId]
         * @param {string} [club]
         * @param {string} [team]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [divisionCategory]
         * @param {number} [weekName]
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {string} [showDivisionName]
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails]
         * @param {string} [matchId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMatchById(matchUniqueId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', weekName?: number, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamMatchesEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMatchById(matchUniqueId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, divisionId, club, team, divisionCategory, weekName, level, showDivisionName, yearDateFrom, yearDateTo, withDetails, matchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} matchSystemId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMatchSystemById(matchSystemId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchSystemEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMatchSystemById(matchSystemId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchesApi - factory interface
 * @export
 */
export const MatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchesApiFp(configuration)
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchSystems(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<MatchSystemEntry>> {
            return localVarFp.findAllMatchSystems(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId]
         * @param {string} [club]
         * @param {string} [team]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [divisionCategory]
         * @param {number} [weekName]
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {string} [showDivisionName]
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails]
         * @param {string} [matchId]
         * @param {string} [matchUniqueId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatches(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', weekName?: number, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, matchUniqueId?: string, options?: any): AxiosPromise<Array<TeamMatchesEntry>> {
            return localVarFp.findAllMatches(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, divisionId, club, team, divisionCategory, weekName, level, showDivisionName, yearDateFrom, yearDateTo, withDetails, matchId, matchUniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} matchUniqueId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId]
         * @param {string} [club]
         * @param {string} [team]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [divisionCategory]
         * @param {number} [weekName]
         * @param {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'} [level]
         * @param {string} [showDivisionName]
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails]
         * @param {string} [matchId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchById(matchUniqueId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', weekName?: number, level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, options?: any): AxiosPromise<TeamMatchesEntry> {
            return localVarFp.findMatchById(matchUniqueId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, divisionId, club, team, divisionCategory, weekName, level, showDivisionName, yearDateFrom, yearDateTo, withDetails, matchId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} matchSystemId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchSystemById(matchSystemId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<MatchSystemEntry> {
            return localVarFp.findMatchSystemById(matchSystemId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllMatchSystems operation in MatchesApi.
 * @export
 * @interface MatchesApiFindAllMatchSystemsRequest
 */
export interface MatchesApiFindAllMatchSystemsRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findAllMatches operation in MatchesApi.
 * @export
 * @interface MatchesApiFindAllMatchesRequest
 */
export interface MatchesApiFindAllMatchesRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {number}
     * @memberof MatchesApiFindAllMatches
     */
    readonly divisionId?: number

    /**
     *
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly club?: string

    /**
     *
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly team?: string

    /**
     *
     * @type {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'}
     * @memberof MatchesApiFindAllMatches
     */
    readonly divisionCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'

    /**
     *
     * @type {number}
     * @memberof MatchesApiFindAllMatches
     */
    readonly weekName?: number

    /**
     *
     * @type {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'}
     * @memberof MatchesApiFindAllMatches
     */
    readonly level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'

    /**
     *
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly showDivisionName?: string

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly yearDateFrom?: string

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly yearDateTo?: string

    /**
     *
     * @type {boolean}
     * @memberof MatchesApiFindAllMatches
     */
    readonly withDetails?: boolean

    /**
     *
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly matchId?: string

    /**
     *
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly matchUniqueId?: string
}

/**
 * Request parameters for findMatchById operation in MatchesApi.
 * @export
 * @interface MatchesApiFindMatchByIdRequest
 */
export interface MatchesApiFindMatchByIdRequest {
    /**
     *
     * @type {number}
     * @memberof MatchesApiFindMatchById
     */
    readonly matchUniqueId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {number}
     * @memberof MatchesApiFindMatchById
     */
    readonly divisionId?: number

    /**
     *
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly club?: string

    /**
     *
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly team?: string

    /**
     *
     * @type {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'}
     * @memberof MatchesApiFindMatchById
     */
    readonly divisionCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'

    /**
     *
     * @type {number}
     * @memberof MatchesApiFindMatchById
     */
    readonly weekName?: number

    /**
     *
     * @type {'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'}
     * @memberof MatchesApiFindMatchById
     */
    readonly level?: 'NATIONAL' | 'HAINAUT' | 'VLAAMS_BRABANT_BR' | 'SUPER_DIVISION' | 'OOST_VLANDEREN' | 'ANTWERP' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'BRUSSELS_BRABANT_WALLON' | 'NAMUR' | 'LIEGE' | 'LUXEMBOURG' | 'REGION_VTTL' | 'IWB'

    /**
     *
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly showDivisionName?: string

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly yearDateFrom?: string

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly yearDateTo?: string

    /**
     *
     * @type {boolean}
     * @memberof MatchesApiFindMatchById
     */
    readonly withDetails?: boolean

    /**
     *
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly matchId?: string
}

/**
 * Request parameters for findMatchSystemById operation in MatchesApi.
 * @export
 * @interface MatchesApiFindMatchSystemByIdRequest
 */
export interface MatchesApiFindMatchSystemByIdRequest {
    /**
     *
     * @type {number}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly matchSystemId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtSeason?: string
}

/**
 * MatchesApi - object-oriented interface
 * @export
 * @class MatchesApi
 * @extends {BaseAPI}
 */
export class MatchesApi extends BaseAPI {
    /**
     *
     * @param {MatchesApiFindAllMatchSystemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public findAllMatchSystems(requestParameters: MatchesApiFindAllMatchSystemsRequest = {}, options?: AxiosRequestConfig) {
        return MatchesApiFp(this.configuration).findAllMatchSystems(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {MatchesApiFindAllMatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public findAllMatches(requestParameters: MatchesApiFindAllMatchesRequest = {}, options?: AxiosRequestConfig) {
        return MatchesApiFp(this.configuration).findAllMatches(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.divisionId, requestParameters.club, requestParameters.team, requestParameters.divisionCategory, requestParameters.weekName, requestParameters.level, requestParameters.showDivisionName, requestParameters.yearDateFrom, requestParameters.yearDateTo, requestParameters.withDetails, requestParameters.matchId, requestParameters.matchUniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {MatchesApiFindMatchByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public findMatchById(requestParameters: MatchesApiFindMatchByIdRequest, options?: AxiosRequestConfig) {
        return MatchesApiFp(this.configuration).findMatchById(requestParameters.matchUniqueId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.divisionId, requestParameters.club, requestParameters.team, requestParameters.divisionCategory, requestParameters.weekName, requestParameters.level, requestParameters.showDivisionName, requestParameters.yearDateFrom, requestParameters.yearDateTo, requestParameters.withDetails, requestParameters.matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {MatchesApiFindMatchSystemByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public findMatchSystemById(requestParameters: MatchesApiFindMatchSystemByIdRequest, options?: AxiosRequestConfig) {
        return MatchesApiFp(this.configuration).findMatchSystemById(requestParameters.matchSystemId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [club]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [playerCategory]
         * @param {number} [uniqueIndex]
         * @param {string} [nameSearch]
         * @param {boolean} [extendedInformation]
         * @param {boolean} [rankingPointsInformation]
         * @param {boolean} [withResults]
         * @param {boolean} [withOpponentRankingEvaluation]
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMembers: async (club?: string, playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (club !== undefined) {
                localVarQueryParameter['club'] = club;
            }

            if (playerCategory !== undefined) {
                localVarQueryParameter['playerCategory'] = playerCategory;
            }

            if (uniqueIndex !== undefined) {
                localVarQueryParameter['uniqueIndex'] = uniqueIndex;
            }

            if (nameSearch !== undefined) {
                localVarQueryParameter['nameSearch'] = nameSearch;
            }

            if (extendedInformation !== undefined) {
                localVarQueryParameter['extendedInformation'] = extendedInformation;
            }

            if (rankingPointsInformation !== undefined) {
                localVarQueryParameter['rankingPointsInformation'] = rankingPointsInformation;
            }

            if (withResults !== undefined) {
                localVarQueryParameter['withResults'] = withResults;
            }

            if (withOpponentRankingEvaluation !== undefined) {
                localVarQueryParameter['withOpponentRankingEvaluation'] = withOpponentRankingEvaluation;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMembersLookup: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/members/lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {string} [club]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [playerCategory]
         * @param {string} [nameSearch]
         * @param {boolean} [extendedInformation]
         * @param {boolean} [rankingPointsInformation]
         * @param {boolean} [withResults]
         * @param {boolean} [withOpponentRankingEvaluation]
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberById: async (uniqueIndex: number, club?: string, playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueIndex' is not null or undefined
            assertParamExists('findMemberById', 'uniqueIndex', uniqueIndex)
            const localVarPath = `/v1/members/{uniqueIndex}`
                .replace(`{${"uniqueIndex"}}`, encodeURIComponent(String(uniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (club !== undefined) {
                localVarQueryParameter['club'] = club;
            }

            if (playerCategory !== undefined) {
                localVarQueryParameter['playerCategory'] = playerCategory;
            }

            if (nameSearch !== undefined) {
                localVarQueryParameter['nameSearch'] = nameSearch;
            }

            if (extendedInformation !== undefined) {
                localVarQueryParameter['extendedInformation'] = extendedInformation;
            }

            if (rankingPointsInformation !== undefined) {
                localVarQueryParameter['rankingPointsInformation'] = rankingPointsInformation;
            }

            if (withResults !== undefined) {
                localVarQueryParameter['withResults'] = withResults;
            }

            if (withOpponentRankingEvaluation !== undefined) {
                localVarQueryParameter['withOpponentRankingEvaluation'] = withOpponentRankingEvaluation;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findMemberEloHistory: async (uniqueIndex: number, season?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueIndex' is not null or undefined
            assertParamExists('findMemberEloHistory', 'uniqueIndex', uniqueIndex)
            const localVarPath = `/v1/members/{uniqueIndex}/elo`
                .replace(`{${"uniqueIndex"}}`, encodeURIComponent(String(uniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {number} [season]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [category]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberNumericRankingsHistory: async (uniqueIndex: number, season?: number, category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueIndex' is not null or undefined
            assertParamExists('findMemberNumericRankingsHistory', 'uniqueIndex', uniqueIndex)
            const localVarPath = `/v1/members/{uniqueIndex}/numeric-rankings`
                .replace(`{${"uniqueIndex"}}`, encodeURIComponent(String(uniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {number} [season]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [category]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberNumericRankingsHistoryV2: async (uniqueIndex: number, season?: number, category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueIndex' is not null or undefined
            assertParamExists('findMemberNumericRankingsHistoryV2', 'uniqueIndex', uniqueIndex)
            const localVarPath = `/v2/members/{uniqueIndex}/numeric-rankings`
                .replace(`{${"uniqueIndex"}}`, encodeURIComponent(String(uniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberControllerIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/members/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} [club]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [playerCategory]
         * @param {number} [uniqueIndex]
         * @param {string} [nameSearch]
         * @param {boolean} [extendedInformation]
         * @param {boolean} [rankingPointsInformation]
         * @param {boolean} [withResults]
         * @param {boolean} [withOpponentRankingEvaluation]
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMembers(club?: string, playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMembers(club, playerCategory, uniqueIndex, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMembersLookup(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMembersLookup(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {string} [club]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [playerCategory]
         * @param {string} [nameSearch]
         * @param {boolean} [extendedInformation]
         * @param {boolean} [rankingPointsInformation]
         * @param {boolean} [withResults]
         * @param {boolean} [withOpponentRankingEvaluation]
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMemberById(uniqueIndex: number, club?: string, playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberById(uniqueIndex, club, playerCategory, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findMemberEloHistory(uniqueIndex: number, season?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WeeklyELO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberEloHistory(uniqueIndex, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {number} [season]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [category]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMemberNumericRankingsHistory(uniqueIndex: number, season?: number, category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WeeklyNumericRanking>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberNumericRankingsHistory(uniqueIndex, season, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {number} [season]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [category]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMemberNumericRankingsHistoryV2(uniqueIndex: number, season?: number, category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WeeklyNumericRankingV2>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberNumericRankingsHistoryV2(uniqueIndex, season, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async memberControllerIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.memberControllerIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         *
         * @param {string} [club]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [playerCategory]
         * @param {number} [uniqueIndex]
         * @param {string} [nameSearch]
         * @param {boolean} [extendedInformation]
         * @param {boolean} [rankingPointsInformation]
         * @param {boolean} [withResults]
         * @param {boolean} [withOpponentRankingEvaluation]
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMembers(club?: string, playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<MemberEntry>> {
            return localVarFp.findAllMembers(club, playerCategory, uniqueIndex, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMembersLookup(options?: any): AxiosPromise<Array<MemberEntry>> {
            return localVarFp.findAllMembersLookup(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {string} [club]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [playerCategory]
         * @param {string} [nameSearch]
         * @param {boolean} [extendedInformation]
         * @param {boolean} [rankingPointsInformation]
         * @param {boolean} [withResults]
         * @param {boolean} [withOpponentRankingEvaluation]
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberById(uniqueIndex: number, club?: string, playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<MemberEntry> {
            return localVarFp.findMemberById(uniqueIndex, club, playerCategory, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {number} [season]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findMemberEloHistory(uniqueIndex: number, season?: number, options?: any): AxiosPromise<Array<WeeklyELO>> {
            return localVarFp.findMemberEloHistory(uniqueIndex, season, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {number} [season]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [category]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberNumericRankingsHistory(uniqueIndex: number, season?: number, category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', options?: any): AxiosPromise<Array<WeeklyNumericRanking>> {
            return localVarFp.findMemberNumericRankingsHistory(uniqueIndex, season, category, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} uniqueIndex
         * @param {number} [season]
         * @param {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'} [category]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberNumericRankingsHistoryV2(uniqueIndex: number, season?: number, category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH', options?: any): AxiosPromise<Array<WeeklyNumericRankingV2>> {
            return localVarFp.findMemberNumericRankingsHistoryV2(uniqueIndex, season, category, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberControllerIndex(options?: any): AxiosPromise<void> {
            return localVarFp.memberControllerIndex(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllMembers operation in MembersApi.
 * @export
 * @interface MembersApiFindAllMembersRequest
 */
export interface MembersApiFindAllMembersRequest {
    /**
     *
     * @type {string}
     * @memberof MembersApiFindAllMembers
     */
    readonly club?: string

    /**
     *
     * @type {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'}
     * @memberof MembersApiFindAllMembers
     */
    readonly playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'

    /**
     *
     * @type {number}
     * @memberof MembersApiFindAllMembers
     */
    readonly uniqueIndex?: number

    /**
     *
     * @type {string}
     * @memberof MembersApiFindAllMembers
     */
    readonly nameSearch?: string

    /**
     *
     * @type {boolean}
     * @memberof MembersApiFindAllMembers
     */
    readonly extendedInformation?: boolean

    /**
     *
     * @type {boolean}
     * @memberof MembersApiFindAllMembers
     */
    readonly rankingPointsInformation?: boolean

    /**
     *
     * @type {boolean}
     * @memberof MembersApiFindAllMembers
     */
    readonly withResults?: boolean

    /**
     *
     * @type {boolean}
     * @memberof MembersApiFindAllMembers
     */
    readonly withOpponentRankingEvaluation?: boolean

    /**
     * Account to do a request
     * @type {string}
     * @memberof MembersApiFindAllMembers
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MembersApiFindAllMembers
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MembersApiFindAllMembers
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MembersApiFindAllMembers
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MembersApiFindAllMembers
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findMemberById operation in MembersApi.
 * @export
 * @interface MembersApiFindMemberByIdRequest
 */
export interface MembersApiFindMemberByIdRequest {
    /**
     *
     * @type {number}
     * @memberof MembersApiFindMemberById
     */
    readonly uniqueIndex: number

    /**
     *
     * @type {string}
     * @memberof MembersApiFindMemberById
     */
    readonly club?: string

    /**
     *
     * @type {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'}
     * @memberof MembersApiFindMemberById
     */
    readonly playerCategory?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'

    /**
     *
     * @type {string}
     * @memberof MembersApiFindMemberById
     */
    readonly nameSearch?: string

    /**
     *
     * @type {boolean}
     * @memberof MembersApiFindMemberById
     */
    readonly extendedInformation?: boolean

    /**
     *
     * @type {boolean}
     * @memberof MembersApiFindMemberById
     */
    readonly rankingPointsInformation?: boolean

    /**
     *
     * @type {boolean}
     * @memberof MembersApiFindMemberById
     */
    readonly withResults?: boolean

    /**
     *
     * @type {boolean}
     * @memberof MembersApiFindMemberById
     */
    readonly withOpponentRankingEvaluation?: boolean

    /**
     * Account to do a request
     * @type {string}
     * @memberof MembersApiFindMemberById
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MembersApiFindMemberById
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MembersApiFindMemberById
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MembersApiFindMemberById
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MembersApiFindMemberById
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findMemberEloHistory operation in MembersApi.
 * @export
 * @interface MembersApiFindMemberEloHistoryRequest
 */
export interface MembersApiFindMemberEloHistoryRequest {
    /**
     *
     * @type {number}
     * @memberof MembersApiFindMemberEloHistory
     */
    readonly uniqueIndex: number

    /**
     *
     * @type {number}
     * @memberof MembersApiFindMemberEloHistory
     */
    readonly season?: number
}

/**
 * Request parameters for findMemberNumericRankingsHistory operation in MembersApi.
 * @export
 * @interface MembersApiFindMemberNumericRankingsHistoryRequest
 */
export interface MembersApiFindMemberNumericRankingsHistoryRequest {
    /**
     *
     * @type {number}
     * @memberof MembersApiFindMemberNumericRankingsHistory
     */
    readonly uniqueIndex: number

    /**
     *
     * @type {number}
     * @memberof MembersApiFindMemberNumericRankingsHistory
     */
    readonly season?: number

    /**
     *
     * @type {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'}
     * @memberof MembersApiFindMemberNumericRankingsHistory
     */
    readonly category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'
}

/**
 * Request parameters for findMemberNumericRankingsHistoryV2 operation in MembersApi.
 * @export
 * @interface MembersApiFindMemberNumericRankingsHistoryV2Request
 */
export interface MembersApiFindMemberNumericRankingsHistoryV2Request {
    /**
     *
     * @type {number}
     * @memberof MembersApiFindMemberNumericRankingsHistoryV2
     */
    readonly uniqueIndex: number

    /**
     *
     * @type {number}
     * @memberof MembersApiFindMemberNumericRankingsHistoryV2
     */
    readonly season?: number

    /**
     *
     * @type {'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'}
     * @memberof MembersApiFindMemberNumericRankingsHistoryV2
     */
    readonly category?: 'MEN' | 'WOMEN' | 'VETERANS' | 'VETERANS_WOMEN' | 'YOUTH'
}

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     *
     * @param {MembersApiFindAllMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findAllMembers(requestParameters: MembersApiFindAllMembersRequest = {}, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findAllMembers(requestParameters.club, requestParameters.playerCategory, requestParameters.uniqueIndex, requestParameters.nameSearch, requestParameters.extendedInformation, requestParameters.rankingPointsInformation, requestParameters.withResults, requestParameters.withOpponentRankingEvaluation, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findAllMembersLookup(options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findAllMembersLookup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {MembersApiFindMemberByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMemberById(requestParameters: MembersApiFindMemberByIdRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findMemberById(requestParameters.uniqueIndex, requestParameters.club, requestParameters.playerCategory, requestParameters.nameSearch, requestParameters.extendedInformation, requestParameters.rankingPointsInformation, requestParameters.withResults, requestParameters.withOpponentRankingEvaluation, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {MembersApiFindMemberEloHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMemberEloHistory(requestParameters: MembersApiFindMemberEloHistoryRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findMemberEloHistory(requestParameters.uniqueIndex, requestParameters.season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {MembersApiFindMemberNumericRankingsHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMemberNumericRankingsHistory(requestParameters: MembersApiFindMemberNumericRankingsHistoryRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findMemberNumericRankingsHistory(requestParameters.uniqueIndex, requestParameters.season, requestParameters.category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {MembersApiFindMemberNumericRankingsHistoryV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMemberNumericRankingsHistoryV2(requestParameters: MembersApiFindMemberNumericRankingsHistoryV2Request, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findMemberNumericRankingsHistoryV2(requestParameters.uniqueIndex, requestParameters.season, requestParameters.category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public memberControllerIndex(options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).memberControllerIndex(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SeasonsApi - axios parameter creator
 * @export
 */
export const SeasonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSeason: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/seasons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCurrentSeason: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/seasons/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SeasonsApi - functional programming interface
 * @export
 */
export const SeasonsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SeasonsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllSeason(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SeasonEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllSeason(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCurrentSeason(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeasonEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCurrentSeason(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SeasonsApi - factory interface
 * @export
 */
export const SeasonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SeasonsApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSeason(options?: any): AxiosPromise<Array<SeasonEntry>> {
            return localVarFp.findAllSeason(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCurrentSeason(options?: any): AxiosPromise<SeasonEntry> {
            return localVarFp.findCurrentSeason(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SeasonsApi - object-oriented interface
 * @export
 * @class SeasonsApi
 * @extends {BaseAPI}
 */
export class SeasonsApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonsApi
     */
    public findAllSeason(options?: AxiosRequestConfig) {
        return SeasonsApiFp(this.configuration).findAllSeason(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonsApi
     */
    public findCurrentSeason(options?: AxiosRequestConfig) {
        return SeasonsApiFp(this.configuration).findCurrentSeason(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TournamentsApi - axios parameter creator
 * @export
 */
export const TournamentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTournaments: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tournaments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTournamentsV2: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/tournaments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} tournamentId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeriesByTournament: async (tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournamentId' is not null or undefined
            assertParamExists('findSeriesByTournament', 'tournamentId', tournamentId)
            const localVarPath = `/v1/tournaments/{tournamentId}/series`
                .replace(`{${"tournamentId"}}`, encodeURIComponent(String(tournamentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} tournamentId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {boolean} [withResults]
         * @param {boolean} [withRegistrations]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTournamentById: async (tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, withResults?: boolean, withRegistrations?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournamentId' is not null or undefined
            assertParamExists('findTournamentById', 'tournamentId', tournamentId)
            const localVarPath = `/v1/tournaments/{tournamentId}`
                .replace(`{${"tournamentId"}}`, encodeURIComponent(String(tournamentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withResults !== undefined) {
                localVarQueryParameter['withResults'] = withResults;
            }

            if (withRegistrations !== undefined) {
                localVarQueryParameter['withRegistrations'] = withRegistrations;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} tournamentId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {boolean} [withResults]
         * @param {boolean} [withRegistrations]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTournamentByIdV2: async (tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, withResults?: boolean, withRegistrations?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournamentId' is not null or undefined
            assertParamExists('findTournamentByIdV2', 'tournamentId', tournamentId)
            const localVarPath = `/v2/tournaments/{tournamentId}`
                .replace(`{${"tournamentId"}}`, encodeURIComponent(String(tournamentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withResults !== undefined) {
                localVarQueryParameter['withResults'] = withResults;
            }

            if (withRegistrations !== undefined) {
                localVarQueryParameter['withRegistrations'] = withRegistrations;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} tournamentId
         * @param {number} serieId
         * @param {RegisterTournament} registerTournament
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerToSerie: async (tournamentId: number, serieId: number, registerTournament: RegisterTournament, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournamentId' is not null or undefined
            assertParamExists('registerToSerie', 'tournamentId', tournamentId)
            // verify required parameter 'serieId' is not null or undefined
            assertParamExists('registerToSerie', 'serieId', serieId)
            // verify required parameter 'registerTournament' is not null or undefined
            assertParamExists('registerToSerie', 'registerTournament', registerTournament)
            const localVarPath = `/v1/tournaments/{tournamentId}/serie/{serieId}/register`
                .replace(`{${"tournamentId"}}`, encodeURIComponent(String(tournamentId)))
                .replace(`{${"serieId"}}`, encodeURIComponent(String(serieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerTournament, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TournamentsApi - functional programming interface
 * @export
 */
export const TournamentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TournamentsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllTournaments(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TournamentEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllTournaments(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllTournamentsV2(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TournamentEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllTournamentsV2(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} tournamentId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSeriesByTournament(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TournamentSerieEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSeriesByTournament(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} tournamentId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {boolean} [withResults]
         * @param {boolean} [withRegistrations]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTournamentById(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, withResults?: boolean, withRegistrations?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TournamentEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTournamentById(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, withResults, withRegistrations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} tournamentId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {boolean} [withResults]
         * @param {boolean} [withRegistrations]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTournamentByIdV2(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, withResults?: boolean, withRegistrations?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TournamentEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTournamentByIdV2(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, withResults, withRegistrations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} tournamentId
         * @param {number} serieId
         * @param {RegisterTournament} registerTournament
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerToSerie(tournamentId: number, serieId: number, registerTournament: RegisterTournament, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerToSerie(tournamentId, serieId, registerTournament, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TournamentsApi - factory interface
 * @export
 */
export const TournamentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TournamentsApiFp(configuration)
    return {
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTournaments(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<TournamentEntry>> {
            return localVarFp.findAllTournaments(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTournamentsV2(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<TournamentEntry>> {
            return localVarFp.findAllTournamentsV2(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} tournamentId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeriesByTournament(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<TournamentSerieEntry>> {
            return localVarFp.findSeriesByTournament(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} tournamentId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {boolean} [withResults]
         * @param {boolean} [withRegistrations]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTournamentById(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, withResults?: boolean, withRegistrations?: boolean, options?: any): AxiosPromise<TournamentEntry> {
            return localVarFp.findTournamentById(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, withResults, withRegistrations, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} tournamentId
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {boolean} [withResults]
         * @param {boolean} [withRegistrations]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTournamentByIdV2(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, withResults?: boolean, withRegistrations?: boolean, options?: any): AxiosPromise<TournamentEntry> {
            return localVarFp.findTournamentByIdV2(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, withResults, withRegistrations, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} tournamentId
         * @param {number} serieId
         * @param {RegisterTournament} registerTournament
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerToSerie(tournamentId: number, serieId: number, registerTournament: RegisterTournament, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<void> {
            return localVarFp.registerToSerie(tournamentId, serieId, registerTournament, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllTournaments operation in TournamentsApi.
 * @export
 * @interface TournamentsApiFindAllTournamentsRequest
 */
export interface TournamentsApiFindAllTournamentsRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiFindAllTournaments
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiFindAllTournaments
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiFindAllTournaments
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiFindAllTournaments
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiFindAllTournaments
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findAllTournamentsV2 operation in TournamentsApi.
 * @export
 * @interface TournamentsApiFindAllTournamentsV2Request
 */
export interface TournamentsApiFindAllTournamentsV2Request {
    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiFindAllTournamentsV2
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiFindAllTournamentsV2
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiFindAllTournamentsV2
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiFindAllTournamentsV2
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiFindAllTournamentsV2
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findSeriesByTournament operation in TournamentsApi.
 * @export
 * @interface TournamentsApiFindSeriesByTournamentRequest
 */
export interface TournamentsApiFindSeriesByTournamentRequest {
    /**
     *
     * @type {number}
     * @memberof TournamentsApiFindSeriesByTournament
     */
    readonly tournamentId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiFindSeriesByTournament
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiFindSeriesByTournament
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiFindSeriesByTournament
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiFindSeriesByTournament
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiFindSeriesByTournament
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findTournamentById operation in TournamentsApi.
 * @export
 * @interface TournamentsApiFindTournamentByIdRequest
 */
export interface TournamentsApiFindTournamentByIdRequest {
    /**
     *
     * @type {number}
     * @memberof TournamentsApiFindTournamentById
     */
    readonly tournamentId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiFindTournamentById
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiFindTournamentById
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiFindTournamentById
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiFindTournamentById
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiFindTournamentById
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {boolean}
     * @memberof TournamentsApiFindTournamentById
     */
    readonly withResults?: boolean

    /**
     *
     * @type {boolean}
     * @memberof TournamentsApiFindTournamentById
     */
    readonly withRegistrations?: boolean
}

/**
 * Request parameters for findTournamentByIdV2 operation in TournamentsApi.
 * @export
 * @interface TournamentsApiFindTournamentByIdV2Request
 */
export interface TournamentsApiFindTournamentByIdV2Request {
    /**
     *
     * @type {number}
     * @memberof TournamentsApiFindTournamentByIdV2
     */
    readonly tournamentId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiFindTournamentByIdV2
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiFindTournamentByIdV2
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiFindTournamentByIdV2
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiFindTournamentByIdV2
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiFindTournamentByIdV2
     */
    readonly xTabtSeason?: string

    /**
     *
     * @type {boolean}
     * @memberof TournamentsApiFindTournamentByIdV2
     */
    readonly withResults?: boolean

    /**
     *
     * @type {boolean}
     * @memberof TournamentsApiFindTournamentByIdV2
     */
    readonly withRegistrations?: boolean
}

/**
 * Request parameters for registerToSerie operation in TournamentsApi.
 * @export
 * @interface TournamentsApiRegisterToSerieRequest
 */
export interface TournamentsApiRegisterToSerieRequest {
    /**
     *
     * @type {number}
     * @memberof TournamentsApiRegisterToSerie
     */
    readonly tournamentId: number

    /**
     *
     * @type {number}
     * @memberof TournamentsApiRegisterToSerie
     */
    readonly serieId: number

    /**
     *
     * @type {RegisterTournament}
     * @memberof TournamentsApiRegisterToSerie
     */
    readonly registerTournament: RegisterTournament

    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiRegisterToSerie
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiRegisterToSerie
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiRegisterToSerie
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiRegisterToSerie
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiRegisterToSerie
     */
    readonly xTabtSeason?: string
}

/**
 * TournamentsApi - object-oriented interface
 * @export
 * @class TournamentsApi
 * @extends {BaseAPI}
 */
export class TournamentsApi extends BaseAPI {
    /**
     *
     * @param {TournamentsApiFindAllTournamentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public findAllTournaments(requestParameters: TournamentsApiFindAllTournamentsRequest = {}, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).findAllTournaments(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TournamentsApiFindAllTournamentsV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public findAllTournamentsV2(requestParameters: TournamentsApiFindAllTournamentsV2Request = {}, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).findAllTournamentsV2(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TournamentsApiFindSeriesByTournamentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public findSeriesByTournament(requestParameters: TournamentsApiFindSeriesByTournamentRequest, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).findSeriesByTournament(requestParameters.tournamentId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TournamentsApiFindTournamentByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public findTournamentById(requestParameters: TournamentsApiFindTournamentByIdRequest, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).findTournamentById(requestParameters.tournamentId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.withResults, requestParameters.withRegistrations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TournamentsApiFindTournamentByIdV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public findTournamentByIdV2(requestParameters: TournamentsApiFindTournamentByIdV2Request, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).findTournamentByIdV2(requestParameters.tournamentId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.withResults, requestParameters.withRegistrations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {TournamentsApiRegisterToSerieRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public registerToSerie(requestParameters: TournamentsApiRegisterToSerieRequest, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).registerToSerie(requestParameters.tournamentId, requestParameters.serieId, requestParameters.registerTournament, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }
}


